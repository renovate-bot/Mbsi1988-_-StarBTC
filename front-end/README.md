# BeL2 Lending Front-end app

## Development

### Start web

Copy `.env.example` to `.env.local`

```sh
yarn
yarn start
```

### Generate production / staging builds

production:

```sh
yarn build:production
```

staging:

```sh
yarn global add env-cmd
yarn build:staging
```

#### Test production builds locally

Start a http server using files that are generated by the build

```sh
python3 -m http.server --directory build 8080
```

### To generate typescript factories from contract ABIs

```sh
yarn run typechain
```

## High level lending workflow:

- Bob places an order and tells how many USDT he is lending
- Alice decides to get this loan and locks her BTC, then she can get the USDT
- Later, Alice repays the USDT and gets her BTC back

## Notes

- Each order created produces a new CONTRACT on chain.
- A factory contract provides a way to create loan contracts, and the subgraph uses this to list all existing loan orders.
- Only USDT on ESC is supported for now.
- Orders must be fully taken, they cannot be partially taken.

## BORROW algorithm

- UI:
  - Generate the preimage for the order user wants to take.
    - For this, we use eth_signTypedData_v4 to sign a payload that contains order id (contract address)
  - Call takeOrder(order id, borrower btc address, borrower btc public key, hashOfPreimage)
    - Use sha256() to hash the preimage
  - Generate the BTC script (bitcoin.script.compile, bitcoin.script.toASM) and compute the script address (bitcoin.payments.p2wsh)
  - Retrieve the BTC amount to pay from the order contract
  - Send BTC to the script address
- Automation/Proof service: 
  - Detects the BTC payment and monitors ZKP verification
  - when verified:
    - Call borrowerProveBtcTransfer() then claimBorrowedToken() on the order contract
- UI:
  - Detect that the order has changed to BORROWED status 
  - Let user know that he now has the tokens + date at which he needs to repay

## REPAY/REFUND algorithm

- Use case: the borrower Alice repays her loan to the lender Bob. Alice clicks "repay" in the UI. (case 1, where bob and alice sign normally - no timeout, no bad actor)
  - Alice's UI:
    - Approve spending by the order contract, amount = borrowed + interest (exacct value given by the order contract)
    - Retrieve the first and unique UTXO of the unlock script address
    - Retrieve the original amount of sats sent by alice to bob
    - Build the raw btc tx (btcRawData) that allows to execute the script
    - Generate alice's signature from essentials (index 0)
      - signature = essentials.signData(rawData: string, script: string, inIndex: number, value: number): Promise<string>;
    - Call borrowerRepayment(btcRawData, signature)
      - This transfers USDT from alice's wallet to the order contract. Order gets marked as REPAID.
  - Bob's UI:
    - Bob sees the order is in REPAID state
    - Get alice's unlock signature from the order contract
    - Generate the raw unlock btc tx in the same way as alice did
    - Bob signs his part of the unlock tx using essentials.signData()
    - Generate the final BTC tx using bob's and alice's signatures
    - Bob publishes the btc tx (already signed by both parties) using any bitcoin wallet
  - Automation/Proof service: 
    - Detects bob's BTC unlock tx and monitors ZKP verification
    - when verified:
      - Call borrowerConfirmReceivedBtc() in order contract
      - Call lenderProveBtcTransfer() in order contract. Order status becomes LENDER_PROOFED.
      - Call closeOrder(). Order is now CLOSED.

- TODO: Other use cases (eg: bob doesn't confirm, timeouts...)

## Flow (TBD)

The normal repayment process is as follows:
 1 Alice is the borrower, and Bob is the lender.
 2 While refunding USDT, Alice needs to prepare the unlocking BTC transaction and provide her own signature.
 3 When Bob observes that Alice has repaid, he needs to add his signature within a certain time frame, assemble the SignedBtcTx, and transmit it to the Bitcoin network for inclusion in a block.
The frontend development required for creating the unlocking BTC transaction includes the following steps:
 1 Alice constructs the unlocking BTC transaction, btcTx, based on the script.
 2 Alice signs the BTC transaction, generating signatureA.
 3 Alice calls the refund method of the contract while providing btcTx and signatureA.
 4 Upon Bob confirming Alice's repayment, he completes his own signature, SignatureB, based on the btcTx provided by Alice. SignatureB is combined with signatureA to form the final signed BTC transaction.
 5 Bob broadcasts the transaction to the Bitcoin network.

## Ways to unlock BTCs after borrowing (TBD)

The locking script has four unlocking methods:

1.Signature unlocking by Alice and Bob
Used for Alice to retrieve BTC after normal borrowing and repayment.

2.Signature unlocking by Alice and Arbiter
Used for Alice to apply for arbitration and retrieve BTC if Bob does not sign after repayment.

3.Signature by Bob and revealing preimage unlocking after LockTime1 
Used for Bob to take Alice's BTC if Alice borrows but does not repay after LockTime1.

4.Signature unlocking by Alice after LockTime2 
Alice pledged BTC but did not successfully borrow or when the first three unlocking conditions are not met. After LockTime2, Alice can retrieve BTC with a single signature.

The preimage:
Alice provides preimageHash when takeOrder.
Alice provides the preimage to Bob when borrowing USDT.

## Specific BTC transaction signatures (TBD)

Process to transfer to lock script. 

1. After Alice takes the order, she reads Bobâ€™s address from the contract, the amount of BTC that needs to be mortgaged, and the loan expiration time.
2. Based on this information, the contract will generate a btyecode of the locking script, and the front end will calculate the locking address based on the btyecode according to the rules of btc
3. Alice transfers the corresponding amount of btc to this address

We have two methods to confirm the transaction
1. In the same way as the previous swap demo, prove it through zkp
2. Confirmed by the counterparty, Alice transfers to the script address, and Bob can directly confirm without zkp. Bob refunds the money to Alice, and Alice confirms it directly without ZKP.

## Favicon generation

- https://realfavicongenerator.net/

## About TESTNET support

Testnet mode support was attempted but failed to be completed for various reasons:
- unisat wallet sendBitcoin() sends transactions that are barely mined even with very high sat/vb, for unknown reasons. Besides, transactions appear in some explorers but not on mempool.
- testnet block times are in the future most of the time. While this is not blocking, this shows bitcoin testnet is in a very bad quality state. Besides this, transactions are packed randomly, sometimes 6 transactions in 20 minutes, while thousands with high sats/vb are awaiting. Testnet miners are garbage.
- OKX wallet cannot sign arbitrary transactions as we need to unlock BTCs and anyway, their testnet version can't sendBitcoin() - provider has a different api than for mainnet.